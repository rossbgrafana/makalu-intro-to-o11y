<!--
author:  Ross Brunson - Grafana Education Architect

mode:    Textbook

comment: Sample Intro to o11y course

-->

# Introduction to Observability
1. Observability Overview
2. From Monitoring to Observability
3. An overview of metrics logs and traces.
4. Why is observability so important?
5. What is Grafana's role in all of this?


<h4>Welcome to the course!</h4>

Please feel free to navigate through the course either sequentially by using the **Forward** and **Back** arrows on the navigation panel at the bottom of the interface, or by clicking on the **Table of Contents** in the left panel.

---

## 1.0 Observability Overview

>   <h4>**Please click the Forward button (at the bottom of each page) to advance.**</h4>

### 1.1 Single-user Systems

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s01-images/01-01_the-early-years-single-user.png?raw=true)

In the beginning, computing was primarily for research, science, and government use. Computers were large and involved one machine in one location – usually a mini-computer or a mainframe.

Really early on, when systems could accommodate only one user and program at a time, they either ran the program successfully or they didn’t. In other words, the only question was, did the program run? Users could answer that themselves by looking at the output from the mainframe.

### 1.2 Multi-user Mainframes

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s01-images/01-02_the-early-years_mainframes.png?raw=true)

Soon, Computing spread to businesses, banking, and industry. Multi-user systems being accessed across distances became the norm. Most computing was still on a large system, like a mainframe.

It became necessary for system administrators to be able to find out information like resource usage and availability. They could answer these questions by connecting to the mainframe and using system utilities to query for information, such as the amount of memory currently being used.

Sysadmins could also read the program’s log files from the mainframe. Logs are records of specified events with time stamps, generated by an application using predefined messages.

At this point, it was relatively easy for sysadmins to understand and figure out where and why any problems were occurring.

### 1.3 Service-Oriented Architecture Systems

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s01-images/01-03_the-early-years_soa-systems.png?raw=true)

As technology evolved it became less expensive to buy lots of smaller computer systems and network them together. This type of system was more flexible and configurable than a mainframe, but it was also more complex. 

Programs started to be called “applications.” Instead of users all accessing a single program that was running on one computer, parts of the application (now called “services”) were often spread across separate computers (called “servers”). 

Complexity was growing, but you could still draw a relatively simple diagram of all of the system parts, whether services or servers.

### 1.4 The Beginning of Monitoring

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s01-images/01-04_the-early-years_begin-monitoring.png?raw=true)

At this point, monitoring became an industry and the idea of using software to periodically measure and record metrics became common.

Metrics measure an aspect of an application or system, such as CPU utilization or network saturation, and record that measurement with a timestamp. With a monitoring system, you could evaluate a metric measurement against a defined standard or baseline. 

Logs were now spread across multiple machines, so software to aggregate them was created. 

At this point, if you could think of something you wanted to measure, record, or monitor, you could automate and aggregate the collection of that information.

### 1.5 Moving to Virtualization

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s01-images/01-05_the-early-years_virtualization.png?raw=true)

Virtualization (runnning software-only copies of an Operating System in a Virtual Machine or VM) enables you to deploy your servers and services with more flexibility by aggregating all your physical resources into one big pool of resources.  

That pool could then be allocated as you wanted or needed. You could almost instantly create new virtual servers and deploy services to them as needed, placing a single VM on a virtualization host, multiple VMs on the same host, or VMs across just parts of physical servers, or even across multiple physical servers.

This flexibility was very useful, but came at the cost of even more complexity and increased reliance on monitoring and logging data. However, it was still possible to monitor how many servers and services were running, where, and how well, when compared to predetermined, expected measures.

### 1.6 Containers and Microservices

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s01-images/01-06_the-early-years_containers-micro.png?raw=true)

Today, many applications are being split into even smaller parts, known as “microservices.” These microservices are often run in containers. Containers are like virtual machines, but require even fewer resources to run, are faster to deploy or remove, and offer even greater flexibility in how and where they are run.

<img align="right" width="250" height="250" src="https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s01-images/01-06-A_cloud-of-insects-diagram.png?raw=true">

Containers and microservices allow changes to the application infrastructure to be automated, spinning up and shutting down components as needed to handle the application load.

This means that there are more “moving parts” in today’s software systems than ever before. Those moving parts are now also interdependent in ways not always easily understood or observed.  Systems are so complex and change so quickly that it has become impossible to draw an accurate system architecture diagram. In the extreme case, architecture diagrams can end up looking something like a cloud of insects, such as you see in the figure to the right.

Both monitoring and logging presume you know the right questions to ask and have configured your application and platform to give you that data. 

With microservices, containers, and automated adjustments to infrastructure based on need, you don’t always know what to ask, much less whether a measurement tells you anything useful, because you aren’t always certain what standard to measure against.

### End of Section Quiz

Which of the following describes following a system request as it travels through multiple components of your application?

[( )] Ollying
[( )] Brokering
[(X)] Tracing
[( )] Measuring
[( )] Chunking


## 2.0 From Monitoring to Observability

>   <h4>**Please click the Forward button (at the bottom of each page) to advance.**</h4>

### 2.1 What is Monitoring?

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s02-images/02-01_what-is-monitoring.png?raw=true)

Monitoring is essentially reading or viewing information from a system or component and interpreting that data to mean something.

Aside from standard monitoring, there are a number of additional monitoring instances, such as these taken from the Google SRE book:

* **White-box monitoring** - Monitoring based on metrics exposed by the internals of the system, including logs, interfaces like the Java Virtual Machine Profiling Interface, or an HTTP handler that emits internal statistics.
* **Black-box monitoring** - Testing externally visible behavior as a user would see it.
* **Root cause** A defect in a software or human system that, if repaired, instills confidence that this event won’t happen again in the same way. 

All to often, Monitoring is: 

* Picking metrics to watch, ignoring others
* Responding to problems you can see
* Wondering about ones you can't see directly, but know there's an issue
* Setting way too many alerts
* Not being able to determine root causes for complex issues

Moving to Observability means not just being passive about what's happening, but starting to be proactive and ask important "hmm, what if..." kind of questions.

### 2.2 Moving from Monitoring to Observability

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s02-images/02-02_monitoring-to-o11y.png?raw=true)

Monitoring is essentially reading or viewing information from a system or component and interpreting that data to mean something.

Aside from standard monitoring, there are a number of additional monitoring scenarios, such as these taken from the [Google SRE Book Chapter 6](https://sre.google/sre-book/monitoring-distributed-systems/):

* White-box monitoring Monitoring based on metrics exposed by the internals of the system, including logs, interfaces like the Java Virtual Machine Profiling Interface, or an HTTP handler that emits internal statistics.
* Black-box monitoring Testing externally visible behavior as a user would see it.
* Root cause A defect in a software or human system that, if repaired, instills confidence that this event won’t happen again in the same way. A given incident might have multiple root causes: for example, perhaps it was caused by a combination of insufficient process automation, software that crashed on bogus input, and insufficient testing of the script used to generate the configuration. Each of these factors might stand alone as a root cause, and each should be repaired.

### 2.3 What is Observability

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s02-images/02-03_what-is-o11y.png?raw=true)

At it's heart, Observability means you can do the following things easily:

* **Gather** - Gathering data is the practice of collecting and correlating as much information as needed about a system or application as it is running.
* **Explore** - Having the ability to explore collected data allows for the correlation of multiple streams and types of collected data to answer new or yet-unanswered questions.
* **Insight** - Having a view of multiple sets of data in configurable and adjustable ways across a platform enables unique views into issues and helps not only answer, but ASK unanticipated questions.

Both metrics monitoring and logging presume you know the right questions to ask and have configured your application and platform to give you that data. With microservices, containers, and automated adjustments to infrastructure based on need, you don’t always know what to ask, much less whether a measurement tells you anything useful, because you aren’t always certain what standard to measure against.

To help you keep today’s systems healthy and running, you need more.

Observability gathers information in a way that enables system operators, DevOps practitioners, and Site Reliability Engineers to ask questions across that information.

These are questions that are not anticipated in advance, but rather questions that arise due to unexpected or novel events within a system. You can look for answers because of the types of data that observability systems record and correlate across sources.

### 2.4 If You Can't Ask Questions...

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s02-images/02-04_if-you-cant-ask.png?raw=true)

What good is your data if you can't do more than just look at it to see if something is wrong?  Observability means that you can collect data, use it traditionally to see if there issues, but since you have that data, and probably more, you can try to look at it in different ways.

Observability allows you to not just ask a question like "Is the service up/down?" and get an answer, but it allows and enables you to ask questions such as "What does this service that is down rely on, and what is the status of that service?"

### 2.5 The Pillars of Observability

![Single User](https://github.com/rossbgrafana/makalu-intro-to-o11y/blob/main/s02-images/02-05_pillars-of-o11y.png?raw=true)

The primary sources of information about a system or application for most people starting their observability journey are metrics, logs, and traces.

Traces are a relatively new type of data. They allow administrators to follow a system request as it travels through multiple components of an application. Traces make it easier to locate which parts of your distributed application are slow or having other problems, so you can narrow down your focus when finding out why an issue occurred and how to fix it.

When you use a system that is designed to help you correlate metrics, logs, and traces in one place, you can even group together the metrics and log messages involved in a single user request, making the process of finding problems faster, leading to better service level measurements and happier customers.

Metrics, logs, and traces have been called the three pillars of observability, but that title is a bit limiting. Let’s remove the word “three” as we continue, combining these and adding others like:

* Visualization
* Alerting
* Synthetic monitoring
* Load testing
* Machine learning with anomaly detection, and
* On-call management

A tool set like this gives you a way to query the data you collect so you are able to locate and fix problems you would have had much more difficulty finding otherwise; this reduces the time needed to fix the problems.

### End of Section Quiz

Which of the following describes following a system request as it travels through multiple components of your application?

[( )] Ollying
[( )] Brokering
[(X)] Tracing
[( )] Measuring
[( )] Chunking

# End of Course Quiz

Which of the following describes following a system request as it travels through multiple components of your application?

[( )] Ollying
[( )] Brokering
[(X)] Tracing
[( )] Measuring
[( )] Chunking

# Command Line Session Examples

In this section we'll run a command and then inspect the output.

1. Run the `ls -l` command against the current directory and look at the output.

<!-- style="background-color: black; color: yellow; font-family: monospace;"-->
> $ ls -l 
    <!-- style="background-color: black; color: white; font-family: monospace;"-->
    <pre>
    drwxr-xr-x   3 rossb  staff       96 Aug  9  2023 Recovery Codes<br>
    drwxr-xr-x@ 21 rossb  staff      672 Sep 28 13:51 cx-best-practice-guides<br>
    drwxr-xr-x@ 16 rossb  staff      512 Oct 10 16:11 grafana-base-setup<br>
    drwxr-xr-x@ 22 rossb  staff      704 Jan 31 09:32 intro-to-mltp<br>
    -rw-r--r--@  1 root   staff  8390443 Feb 12 17:27 intro-to-o11y.zip<br>
    drwxr-xr-x@ 10 rossb  staff      320 Feb 12 17:25 makalu-intro-to-o11y</pre>

2.  Now run the `pwd` command to print the current directory.

<!-- style="background-color: black; color: yellow; font-family: monospace;"-->
> $ pwd 
    <!-- style="background-color: black; color: white; font-family: monospace;"-->
    <pre>
    /Users/rossb/github
    </pre>
